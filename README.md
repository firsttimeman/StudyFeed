📘 커뮤니티 피드 모임서비스

**기간** : 2025.08 ~ 2025.10

**개발 인원** : 개인 프로젝트

**기술 스택** :

Spring Boot 3.x, Java 17, JPA(Hibernate 6), Spring Security (JWT), Validation, AWS S3, MySQL, Redis, Swagger(OpenAPI)

---

### **💡 프로젝트 개요**

스터디나 운동 모임 사용자들이 하루의 기록과 경험을 공유할 수 있는 피드형 커뮤니티 서비스입니다.

게시글(피드)과 이미지 업로드, 댓글·대댓글, 좋아요 기능을 제공하며, JWT 기반 인증을 적용했습니다.

사용자 간 소통과 정보 공유를 위한 모임 중심 피드 커뮤니티 플랫폼을 구축했습니다. 단순한 CRUD가 아닌 실시간성·안정성·확장성을 고려한 구조 설계를 목표로 했습니다.

---

### **🧱 주요 기능**

| **구분** | **설명** |
| --- | --- |
| 회원 인증 | JWT 기반 로그인/회원가입, Access & Refresh Token 구조 |
| 피드 관리 | 텍스트/이미지 기반 피드 작성, 수정, 삭제 |
| 댓글 시스템 | 댓글/대댓글 작성 및 삭제, 부모-자식 구조 유지 |
| 좋아요 기능 | 동시성 제어(분산 락) 기반 좋아요 토글 |
| 홈 피드 조회 | 카테고리별 최신 피드 페이지네이션 조회 |
| 유저 관리 | 닉네임 생성, 프로필 수정, 자기소개 변경 등 |
| 모임 관리 | 모임을 생성하여 관련 주제에 맞는 사람들을 모집 |

---

### **🔒 인증 / 보안 설계**

- Spring Security + JWT 기반의 인증/인가 체계 구축
- Access Token 만료 시 Refresh Token으로 재발급 (/api/auth/refresh)
- @PreAuthorize 를 이용한 권한별 접근 제어
- 비밀번호는 BCrypt 암호화 저장

---

### **🧩 피드 구조 설계**

- 피드(Feed)는 유저(User)와 다대일(N:1) 관계
- 피드 내 이미지(FeedImage)는 1:N 관계
- 좋아요(FeedLike) 테이블을 별도 분리해 멱등성 확보 (유저·피드 복합 unique index)
- 댓글(FeedComment)은 **2단 구조** (댓글/대댓글)로 설계
    - soft delete 지원 (isDeleted=true)
    - 부모 댓글의 replyCount 원자적 증가 (UPDATE ... SET reply_count = reply_count + 1)

---

### **⚙️ 동시성 제어**

- **좋아요 토글 시 중복 클릭 문제 해결**
    - @DistributeLock("lock:feed-like:{feedId}") 기반 Redisson 분산 락 적용
    - 멱등성 유지 : 이미 존재하는 좋아요 요청 시 무시 처리
    - DB-level unique index (feed_id + user_id) 로 최종 무결성 보장

**결과:** 다중 요청 시 중복 Like/Unlike 문제 완전 제거

---

### 📂 이미지 업로드

- AWS S3를 사용한 이미지 저장
- 파일명은 `UUID + 확장자` 형태로 생성해 충돌 방지 (`feed/{userId}/{uuid}.ext` 패턴)
- **이미지 업로드 전용 API 분리**
    - `/api/feed/images` : `MultipartFile` 리스트를 받아 S3에만 업로드
    - 업로드가 완료되면 S3 URL 리스트를 응답으로 반환
- 피드 생성/수정 API에서는 **이미 업로드된 S3 URL만 전달 받아 DB에 매핑**
    - `FeedRequest.addedImagesUrls` : 새로 추가된 이미지 S3 URL 리스트
    - `FeedRequest.deletedImagesUrls` : 삭제할 이미지 S3 URL 리스트
- 피드 삭제 및 이미지 삭제 시
    - DB에서는 `FeedImage` 엔티티를 우선 삭제
    - 트랜잭션 커밋 이후(`afterCommit`)에 S3에서 실제 파일 삭제 (best-effort)
- S3 URL에서 key를 추출하는 헬퍼(`extractKeyFromUrl`)를 사용해 버킷/도메인 변경에도 유연하게 대응

---

### **⚡ 성능 최적화**

- **좋아요 여부 조회 최적화**

  → 조회된 피드 ID 집합을 기준으로 한 번에 좋아요 목록 쿼리 후 Set<Long> 으로 매핑

- **댓글/대댓글 조회 최적화**

  → fetch join + DTO projection으로 N+1 방지

- **홈 피드 조회**

  → Pageable 기반 쿼리 + 카테고리 인덱스, hasNext 계산


---

### **🧾 예외 처리 및 응답 구조**

- @RestControllerAdvice + ErrorCode Enum 기반 전역 예외 처리
- 모든 에러를 JSON 형태로 응답

```
{
  "errorCode": "COMMENT_NOT_FOUND",
  "message": "해당 댓글을 찾을 수 없습니다."
}
```

---

### **🚀 트러블슈팅 / 개선 사례**

### **1️⃣  피드 좋아요 중복 요청으로 인한 Race Condition 발생**

- **문제 상황**

  여러 사용자가 동시에 같은 피드에 좋아요 요청을 보낼 때,

  중복 저장이 발생하거나 like_count 값이 비정상적으로 증가하는 문제가 발생했습니다.

- **해결 과정**
    - Redis 기반 **분산 락(@DistributeLock)** 을 적용하여 같은 피드에 대한 동시에 접근을 제어했습니다.
    - DB 레벨에서도 (feed_id, user_id) 복합 **unique index** 를 추가해 최종 무결성을 보장했습니다.
    - 테스트를 통해 멀티 스레드 환경에서도 중복 저장 없이 정확한 Like/Unlike 토글이 유지됨을 확인했습니다.
- **성과**

  중복 좋아요 및 좋아요 수 불일치 현상을 제거했으며,

  동시성 제어 패턴(분산 락 + unique index)을 적용할 수 있었습니다.


---

### **2️⃣ 대댓글 삭제 시 부모 댓글의 replyCount 불일치 문제**

- **문제 상황**

  대댓글이 삭제될 때 부모 댓글의 replyCount가 즉시 반영되지 않아,

  댓글 개수가 실제와 다르게 표시되는 문제가 발생했습니다.

- **해결 과정**
    - 부모 댓글의 replyCount 필드를 단순 조회 후 저장하는 대신,

      **DB 단일 쿼리(Update Set)** 기반의 원자적 연산으로 처리했습니다.

    - 삭제/복원 모두 동일 로직으로 관리되도록 트랜잭션 내에서 일관성 보장했습니다.
- **성과**

  DB 레벨에서의 원자 연산으로 데이터 정합성을 확보하고,

  트랜잭션 경계를 명확히 하여 예외 발생 시 자동 롤백이 보장되었습니다.


---

### 3️⃣ 이미지 업로드/삭제 시 S3 – DB 정합성과 트랜잭션 홀드 문제

**문제 상황**

초기 버전에서는 피드 생성/수정 시

- 하나의 요청에서
    - S3 업로드 + DB 저장을 동시에 처리하고,
    - 실패 시 업로드된 일부 파일을 보상 삭제하는 구조였습니다.

이 방식은 기능적으로는 동작했지만,

- S3 네트워크 지연이 발생하면 **DB 트랜잭션이 길게 잡히는 문제**
- 예외 상황에서 S3와 DB 상태를 항상 100% 맞추기 위해 복잡한 보상 로직 필요

같은 부담이 있었습니다.

---

**해결 과정**

- 이미지 업로드를 **피드 트랜잭션과 완전히 분리**하는 방향으로 구조를 변경했습니다.
    - `/api/feed/images`
      → `MultipartFile` 리스트를 받아 **S3에만 업로드**하고, 업로드된 S3 URL 리스트를 반환
    - `/api/feed/create`, `/api/feed/{id}` (수정)
      → 클라이언트가 전달한 `addedImagesUrls`, `deletedImagesUrls` 기준으로 **DB에만 반영**
- 삭제 흐름도 다음과 같이 나누었습니다.
    1. 트랜잭션 내부에서
        - 삭제할 `FeedImage`들을 조회 (`findAllByImageUrlInWithFeed`)
        - 소유자 검증(해당 피드의 이미지인지 확인)
        - `deleteAllInBatch`로 DB에서 일괄 삭제
        - 실제 S3 URL 목록만 따로 수집
    2. 트랜잭션 커밋 이후(`afterCommit`)에
        - 수집해둔 URL 목록을 바탕으로 S3 삭제 시도
        - 실패 시 서비스 로직에는 영향 없이 로그만 남기도록 처리

---

### **💬 프로젝트를 통해 배운 점**

- JWT 기반 인증 흐름과 토큰 갱신 구조를 직접 설계하며 보안 흐름을 명확히 이해
- JPA 엔티티 관계 설계 시, 연관관계보다 쿼리 주도 설계가 중요함을 체감
- Redis 기반 분산 락과 멱등성 처리를 통해 실무 수준의 동시성 제어 경험
- 단순 CRUD보다 데이터 일관성과 트랜잭션 안정성이 핵심임을 실감

---

### **📈 향후 개선 계획**

- 피드 정렬 기준 다양화 (인기순 / 최신순)
- Elasticsearch 도입 예정 (검색 고도화)
- WebSocket 기반 알림 기능 연동 (Redis Pub/Sub 기반)
- S3 Presigned URL을 이용한 보안 강화

---